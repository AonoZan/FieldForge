name: Build Linux Addon Release

on:
  push:
    tags:
      - 'v*' # Trigger on tags like v1.0.0
  workflow_dispatch:
    inputs:
      # Define an input for the version/tag name when run manually
      version_tag:
        description: 'Version tag to build (e.g., v1.0.0 or v1.1.0-beta)'
        required: true
        type: string

env:
  LIBFIVE_CHECKOUT_DIR: libfive_src
  CMAKE_BUILD_TYPE: Release
  LIBFIVE_COMMIT_SHA: '71899313d36ce14de6646ef760fa6bbc5c0cc067'

jobs:
  build_and_package_linux:
    name: Build libfive and Package Addon (Linux)
    runs-on: [self-hosted, linux, x64, local-run] # <-- ADJUST TO YOUR LINUX RUNNER LABELS

    steps:
      # --- Build libfive ---
      - name: Checkout libfive Source Code
        uses: actions/checkout@v4
        with:
          repository: libfive/libfive
          ref: ${{ env.LIBFIVE_COMMIT_SHA }}
          path: ${{ env.LIBFIVE_CHECKOUT_DIR }}

      # - name: Install libfive dependencies via apt # Ensure apt/sudo works OR pre-install
      #   run: |
      #     sudo apt-get update
      #     sudo apt-get install -y build-essential cmake libeigen3-dev libpng-dev zlib1g-dev
      # === END OF COMMENTED STEP ===

      - name: Configure CMake for libfive
        run: cmake -S ${{ env.LIBFIVE_CHECKOUT_DIR }} -B build -DCMAKE_BUILD_TYPE=${{ env.CMAKE_BUILD_TYPE }} -DBUILD_SHARED_LIBS=ON -DLIBFIVE_BUILD_STUDIO=OFF

      # === CHANGE: Build only, NO install ===
      - name: Build libfive
        run: cmake --build build --config ${{ env.CMAKE_BUILD_TYPE }}

      # --- Package Addon ---
      - name: Checkout Addon Repository Code
        uses: actions/checkout@v4
        with:
          path: addon_code

      - name: Determine Version
        id: get_version
        # If triggered manually, use the input. If triggered by tag, use the tag name.
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "VERSION=${{ github.event.inputs.version_tag }}" >> $GITHUB_ENV
          else
            echo "VERSION=${GITHUB_REF#refs/tags/}" >> $GITHUB_ENV
          fi
        shell: bash

      - name: Create staging directory structure
        run: |
          mkdir -p staging/FieldForge
          mkdir -p staging/FieldForge/libfive/src
          mkdir -p staging/FieldForge/libfive/stdlib

      - name: Copy Addon Python files
        run: |
          cp addon_code/__init__.py staging/FieldForge/
          cp addon_code/libfive/*.py staging/FieldForge/libfive/
          cp addon_code/libfive/stdlib/*.py staging/FieldForge/libfive/stdlib/
        shell: bash

      - name: Copy Compiled Linux Libraries from Build
        # Copy directly from the install directory created earlier in THIS job
        run: |
          cp build/libfive/libfive.so staging/FieldForge/libfive/src/
          cp build/libfive/libfive-stdlib.so staging/FieldForge/libfive/stdlib/

      - name: Create Linux zip file
        run: |
          cd staging
          zip -r ../FieldForge-lin-${{ env.VERSION }}.zip FieldForge/
          cd ..
        shell: bash

      # --- Create/Update GitHub Release ---
      - name: Create Release and Upload Linux Asset
        uses: softprops/action-gh-release@v1
        # NOTE: This will try to create/update a release named after the INPUT tag
        # Be careful when running manually - ensure the input tag matches an intended release
        with:
          # Use the input tag name when run manually, otherwise the pushed tag
          tag_name: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.version_tag || github.ref_name }}
          name: Release ${{ env.VERSION }} (libfive @${{ env.LIBFIVE_COMMIT_SHA }})
          draft: false
          # Prerelease check now uses the determined version string
          prerelease: contains(env.VERSION, '-')
          # Use determined version in the filename
          files: FieldForge-lin-${{ env.VERSION }}.zip
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
